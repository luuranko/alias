{"ast":null,"code":"window.myDebug = require('debug');\nvar Peer = require('simple-peer');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-p2p-parser');\nvar toArray = require('to-array');\nvar hasBin = require('has-binary');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket');\nvar hat = require('hat');\nvar extend = require('extend.js');\nvar rtcSupport = require('webrtcsupport');\nvar emitfn = Emitter.prototype.emit;\nfunction Socketiop2p(socket, opts, cb) {\n  var self = this;\n  self.useSockets = true;\n  self.usePeerConnection = false;\n  self.decoder = new parser.Decoder(this);\n  self.decoder.on('decoded', bind(this, this.ondecoded));\n  self.socket = socket;\n  self.cb = cb;\n  self._peers = {};\n  self.readyPeers = 0;\n  self.ready = false;\n  self._peerEvents = {\n    upgrade: 1,\n    error: 1,\n    peer_signal: 1,\n    peer_ready: 1,\n    stream: 1\n  };\n  var defaultOpts = {\n    autoUpgrade: true,\n    numClients: 5\n  };\n  self.opts = extend(defaultOpts, opts || {});\n  self.peerOpts = self.opts.peerOpts || {};\n  self.numConnectedClients;\n  socket.on('numClients', function (numClients) {\n    self.peerId = socket.io.engine.id;\n    self.numConnectedClients = numClients;\n    if (rtcSupport.supportDataChannel) {\n      generateOffers(function (offers) {\n        var offerObj = {\n          offers: offers,\n          fromPeerId: self.peerId\n        };\n        socket.emit('offers', offerObj);\n      });\n    }\n    function generateOffers(cb) {\n      var offers = [];\n      for (var i = 0; i < self.opts.numClients; ++i) {\n        generateOffer();\n      }\n      function generateOffer() {\n        var offerId = hat(160);\n        var peerOpts = extend(self.peerOpts, {\n          initiator: true\n        });\n        var peer = self._peers[offerId] = new Peer(peerOpts);\n        peer.setMaxListeners(50);\n        self.setupPeerEvents(peer);\n        peer.on('signal', function (offer) {\n          offers.push({\n            offer: offer,\n            offerId: offerId\n          });\n          checkDone();\n        });\n        peer.on('error', function (err) {\n          emitfn.call(this, 'peer-error', err);\n          debug('Error in peer %s', err);\n        });\n      }\n      function checkDone() {\n        if (offers.length === self.opts.numClients) {\n          debug('generated %s offers', self.opts.numClients);\n          cb(offers);\n        }\n      }\n    }\n  });\n  socket.on('offer', function (data) {\n    var peerOpts = extend(self.peerOpts, {\n      initiator: false\n    });\n    var peer = self._peers[data.fromPeerId] = new Peer(peerOpts);\n    self.numConnectedClients++;\n    peer.setMaxListeners(50);\n    self.setupPeerEvents(peer);\n    peer.on('signal', function (signalData) {\n      var signalObj = {\n        signal: signalData,\n        offerId: data.offerId,\n        fromPeerId: self.peerId,\n        toPeerId: data.fromPeerId\n      };\n      socket.emit('peer-signal', signalObj);\n    });\n    peer.on('error', function (err) {\n      emitfn.call(this, 'peer-error', err);\n      debug('Error in peer %s', err);\n    });\n    peer.signal(data.offer);\n  });\n  socket.on('peer-signal', function (data) {\n    // Select peer from offerId if exists\n    var peer = self._peers[data.offerId] || self._peers[data.fromPeerId];\n    peer.on('signal', function signal(signalData) {\n      var signalObj = {\n        signal: signalData,\n        offerId: data.offerId,\n        fromPeerId: self.peerId,\n        toPeerId: data.fromPeerId\n      };\n      socket.emit('peer-signal', signalObj);\n    });\n    peer.signal(data.signal);\n  });\n  self.on('peer_ready', function (peer) {\n    self.readyPeers++;\n    if (self.readyPeers >= self.numConnectedClients && !self.ready) {\n      self.ready = true;\n      if (self.opts.autoUpgrade) self.usePeerConnection = true;\n      if (typeof self.cb === 'function') self.cb();\n      self.emit('upgrade');\n    }\n  });\n}\nEmitter(Socketiop2p.prototype);\nSocketiop2p.prototype.setupPeerEvents = function (peer) {\n  var self = this;\n  peer.on('connect', function (peer) {\n    self.emit('peer_ready', peer);\n  });\n  peer.on('data', function (data) {\n    if (this.destroyed) return;\n    self.decoder.add(data);\n  });\n  peer.on('stream', function (stream) {\n    self.emit('stream', stream);\n  });\n};\n\n/**\n * Overwride the inheritted 'on' method to add a listener to the socket instance\n * that emits the event on the Socketio event loop\n**/\n\nSocketiop2p.prototype.on = function (type, listener) {\n  var self = this;\n  this.socket.addEventListener(type, function (data) {\n    emitfn.call(self, type, data);\n  });\n  this.addEventListener(type, listener);\n};\nSocketiop2p.prototype.emit = function (data, cb) {\n  var self = this;\n  var argsObj = cb || {};\n  var encoder = new parser.Encoder();\n  if (this._peerEvents.hasOwnProperty(data) || argsObj.fromSocket) {\n    emitfn.apply(this, arguments);\n  } else if (this.usePeerConnection || !this.useSockets) {\n    var args = toArray(arguments);\n    var parserType = parser.EVENT; // default\n    if (hasBin(args)) {\n      parserType = parser.BINARY_EVENT;\n    } // binary\n    var packet = {\n      type: parserType,\n      data: args\n    };\n    encoder.encode(packet, function (encodedPackets) {\n      if (encodedPackets[1] instanceof ArrayBuffer) {\n        self._sendArray(encodedPackets);\n      } else if (encodedPackets) {\n        for (var i = 0; i < encodedPackets.length; i++) {\n          self._send(encodedPackets[i]);\n        }\n      } else {\n        throw new Error('Encoding error');\n      }\n    });\n  } else {\n    this.socket.emit(data, cb);\n  }\n};\n\n/**\n* If the second packet is a binary attachment,\n* swap out the attachment number for the number of chunks in the array\n* before sending the new packet and chunks\n**/\n\nSocketiop2p.prototype._sendArray = function (arr) {\n  var firstPacket = arr[0];\n  var interval = 5000;\n  var arrLength = arr[1].byteLength;\n  var nChunks = Math.ceil(arrLength / interval);\n  var packetData = firstPacket.substr(0, 1) + nChunks + firstPacket.substr(firstPacket.indexOf('-'));\n  this._send(packetData);\n  this.binarySlice(arr[1], interval, this._send);\n};\nSocketiop2p.prototype._send = function (data) {\n  var self = this;\n  for (var peerId in self._peers) {\n    var peer = self._peers[peerId];\n    if (peer._channelReady) {\n      peer.send(data);\n    }\n  }\n};\nSocketiop2p.prototype.binarySlice = function (arr, interval, callback) {\n  for (var start = 0; start < arr.byteLength; start += interval) {\n    var chunk = arr.slice(start, start + interval);\n    callback.call(this, chunk);\n  }\n};\nSocketiop2p.prototype.ondecoded = function (packet) {\n  var args = packet.data || [];\n  emitfn.apply(this, args);\n};\nSocketiop2p.prototype.disconnect = function () {\n  for (var peerId in this._peers) {\n    var peer = this._peers[peerId];\n    peer.destroy();\n    this.socket.disconnect();\n  }\n};\n\n/**\n * Use peerConnection instead of socket.io one.\n**/\nSocketiop2p.prototype.upgrade = function () {\n  this.usePeerConnection = true;\n};\nmodule.exports = Socketiop2p;","map":{"version":3,"names":["window","myDebug","require","Peer","Emitter","parser","toArray","hasBin","bind","debug","hat","extend","rtcSupport","emitfn","prototype","emit","Socketiop2p","socket","opts","cb","self","useSockets","usePeerConnection","decoder","Decoder","on","ondecoded","_peers","readyPeers","ready","_peerEvents","upgrade","error","peer_signal","peer_ready","stream","defaultOpts","autoUpgrade","numClients","peerOpts","numConnectedClients","peerId","io","engine","id","supportDataChannel","generateOffers","offers","offerObj","fromPeerId","i","generateOffer","offerId","initiator","peer","setMaxListeners","setupPeerEvents","offer","push","checkDone","err","call","length","data","signalData","signalObj","signal","toPeerId","destroyed","add","type","listener","addEventListener","argsObj","encoder","Encoder","hasOwnProperty","fromSocket","apply","arguments","args","parserType","EVENT","BINARY_EVENT","packet","encode","encodedPackets","ArrayBuffer","_sendArray","_send","Error","arr","firstPacket","interval","arrLength","byteLength","nChunks","Math","ceil","packetData","substr","indexOf","binarySlice","_channelReady","send","callback","start","chunk","slice","disconnect","destroy","module","exports"],"sources":["/home/xilxilx/projects/distsys/alias/frontend/node_modules/socket.io-p2p/index.js"],"sourcesContent":["window.myDebug = require('debug')\nvar Peer = require('simple-peer')\nvar Emitter = require('component-emitter')\nvar parser = require('socket.io-p2p-parser')\nvar toArray = require('to-array')\nvar hasBin = require('has-binary')\nvar bind = require('component-bind')\nvar debug = require('debug')('socket')\nvar hat = require('hat')\nvar extend = require('extend.js')\nvar rtcSupport = require('webrtcsupport')\n\nvar emitfn = Emitter.prototype.emit\n\nfunction Socketiop2p (socket, opts, cb) {\n  var self = this\n  self.useSockets = true\n  self.usePeerConnection = false\n  self.decoder = new parser.Decoder(this)\n  self.decoder.on('decoded', bind(this, this.ondecoded))\n  self.socket = socket\n  self.cb = cb\n  self._peers = {}\n  self.readyPeers = 0\n  self.ready = false\n  self._peerEvents = {\n                   upgrade: 1,\n                   error: 1,\n                   peer_signal: 1,\n                   peer_ready: 1,\n                   stream: 1\n                 }\n  var defaultOpts = {\n    autoUpgrade: true,\n    numClients: 5\n  }\n  self.opts = extend(defaultOpts, (opts || {}))\n  self.peerOpts = self.opts.peerOpts || {}\n  self.numConnectedClients\n\n  socket.on('numClients', function (numClients) {\n    self.peerId = socket.io.engine.id\n    self.numConnectedClients = numClients\n    if (rtcSupport.supportDataChannel) {\n      generateOffers(function (offers) {\n        var offerObj = {\n          offers: offers,\n          fromPeerId: self.peerId\n        }\n        socket.emit('offers', offerObj)\n      })\n    }\n\n    function generateOffers (cb) {\n      var offers = []\n      for (var i = 0; i < self.opts.numClients; ++i) {\n        generateOffer()\n      }\n      function generateOffer () {\n        var offerId = hat(160)\n        var peerOpts = extend(self.peerOpts, {initiator: true})\n        var peer = self._peers[offerId] = new Peer(peerOpts)\n        peer.setMaxListeners(50)\n        self.setupPeerEvents(peer)\n        peer.on('signal', function (offer) {\n          offers.push({\n            offer: offer,\n            offerId: offerId\n          })\n          checkDone()\n        })\n\n        peer.on('error', function (err) {\n          emitfn.call(this, 'peer-error', err)\n          debug('Error in peer %s', err)\n        })\n      }\n\n      function checkDone () {\n        if (offers.length === self.opts.numClients) {\n          debug('generated %s offers', self.opts.numClients)\n          cb(offers)\n        }\n      }\n    }\n  })\n\n  socket.on('offer', function (data) {\n    var peerOpts = extend(self.peerOpts, {initiator: false})\n    var peer = self._peers[data.fromPeerId] = new Peer(peerOpts)\n    self.numConnectedClients++\n    peer.setMaxListeners(50)\n    self.setupPeerEvents(peer)\n    peer.on('signal', function (signalData) {\n      var signalObj = {\n        signal: signalData,\n        offerId: data.offerId,\n        fromPeerId: self.peerId,\n        toPeerId: data.fromPeerId\n      }\n      socket.emit('peer-signal', signalObj)\n    })\n\n    peer.on('error', function (err) {\n      emitfn.call(this, 'peer-error', err)\n      debug('Error in peer %s', err)\n    })\n    peer.signal(data.offer)\n  })\n\n  socket.on('peer-signal', function (data) {\n    // Select peer from offerId if exists\n    var peer = self._peers[data.offerId] || self._peers[data.fromPeerId]\n\n    peer.on('signal', function signal (signalData) {\n      var signalObj = {\n        signal: signalData,\n        offerId: data.offerId,\n        fromPeerId: self.peerId,\n        toPeerId: data.fromPeerId\n      }\n      socket.emit('peer-signal', signalObj)\n    })\n\n    peer.signal(data.signal)\n  })\n\n  self.on('peer_ready', function (peer) {\n    self.readyPeers++\n    if (self.readyPeers >= self.numConnectedClients && !self.ready) {\n      self.ready = true\n      if (self.opts.autoUpgrade) self.usePeerConnection = true\n      if (typeof self.cb === 'function') self.cb()\n      self.emit('upgrade')\n    }\n  })\n\n}\n\nEmitter(Socketiop2p.prototype)\n\nSocketiop2p.prototype.setupPeerEvents = function (peer) {\n  var self = this\n\n  peer.on('connect', function (peer) {\n    self.emit('peer_ready', peer)\n  })\n\n  peer.on('data', function (data) {\n    if (this.destroyed) return\n    self.decoder.add(data)\n  })\n\n  peer.on('stream', function (stream) {\n    self.emit('stream', stream)\n  })\n}\n\n/**\n * Overwride the inheritted 'on' method to add a listener to the socket instance\n * that emits the event on the Socketio event loop\n**/\n\nSocketiop2p.prototype.on = function (type, listener) {\n  var self = this\n  this.socket.addEventListener(type, function (data) {\n    emitfn.call(self, type, data)\n  })\n  this.addEventListener(type, listener)\n}\n\nSocketiop2p.prototype.emit = function (data, cb) {\n  var self = this\n  var argsObj = cb || {}\n  var encoder = new parser.Encoder()\n\n  if (this._peerEvents.hasOwnProperty(data) || argsObj.fromSocket) {\n    emitfn.apply(this, arguments)\n  } else if (this.usePeerConnection || !this.useSockets) {\n    var args = toArray(arguments)\n    var parserType = parser.EVENT // default\n    if (hasBin(args)) { parserType = parser.BINARY_EVENT } // binary\n    var packet = { type: parserType, data: args}\n\n    encoder.encode(packet, function (encodedPackets) {\n      if (encodedPackets[1] instanceof ArrayBuffer) {\n        self._sendArray(encodedPackets)\n      } else if (encodedPackets) {\n        for (var i = 0; i < encodedPackets.length; i++) {\n          self._send(encodedPackets[i])\n        }\n      } else {\n        throw new Error('Encoding error')\n      }\n    })\n  } else {\n    this.socket.emit(data, cb)\n  }\n}\n\n/**\n* If the second packet is a binary attachment,\n* swap out the attachment number for the number of chunks in the array\n* before sending the new packet and chunks\n**/\n\nSocketiop2p.prototype._sendArray = function (arr) {\n  var firstPacket = arr[0]\n  var interval = 5000\n  var arrLength = arr[1].byteLength\n  var nChunks = Math.ceil(arrLength / interval)\n  var packetData = firstPacket.substr(0, 1) + nChunks + firstPacket.substr(firstPacket.indexOf('-'))\n  this._send(packetData)\n  this.binarySlice(arr[1], interval, this._send)\n}\n\nSocketiop2p.prototype._send = function (data) {\n  var self = this\n  for (var peerId in self._peers) {\n    var peer = self._peers[peerId]\n    if (peer._channelReady) {\n      peer.send(data)\n    }\n  }\n}\n\nSocketiop2p.prototype.binarySlice = function (arr, interval, callback) {\n  for (var start = 0; start < arr.byteLength; start += interval) {\n    var chunk = arr.slice(start, start + interval)\n    callback.call(this, chunk)\n  }\n}\n\nSocketiop2p.prototype.ondecoded = function (packet) {\n  var args = packet.data || []\n  emitfn.apply(this, args)\n}\n\nSocketiop2p.prototype.disconnect = function () {\n  for (var peerId in this._peers) {\n    var peer = this._peers[peerId]\n    peer.destroy()\n    this.socket.disconnect()\n  }\n}\n\n/**\n * Use peerConnection instead of socket.io one.\n**/\nSocketiop2p.prototype.upgrade = function () {\n  this.usePeerConnection = true\n}\n\nmodule.exports = Socketiop2p\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}