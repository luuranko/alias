{"ast":null,"code":"/* global Blob */\n\nmodule.exports = Peer;\nvar debug = require('debug')('simple-peer');\nvar getBrowserRTC = require('get-browser-rtc');\nvar hat = require('hat');\nvar inherits = require('inherits');\nvar isTypedArray = require('is-typedarray');\nvar once = require('once');\nvar stream = require('stream');\ninherits(Peer, stream.Duplex);\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nfunction Peer(opts) {\n  var self = this;\n  if (!(self instanceof Peer)) return new Peer(opts);\n  self._debug('new peer %o', opts);\n  if (!opts) opts = {};\n  opts.allowHalfOpen = false;\n  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024;\n  stream.Duplex.call(self, opts);\n  self.initiator = opts.initiator || false;\n  self.channelConfig = opts.channelConfig || Peer.channelConfig;\n  self.channelName = opts.initiator ? opts.channelName || hat(160) : null;\n  self.config = opts.config || Peer.config;\n  self.constraints = opts.constraints || Peer.constraints;\n  self.offerConstraints = opts.offerConstraints;\n  self.answerConstraints = opts.answerConstraints;\n  self.reconnectTimer = opts.reconnectTimer || false;\n  self.sdpTransform = opts.sdpTransform || function (sdp) {\n    return sdp;\n  };\n  self.stream = opts.stream || false;\n  self.trickle = opts.trickle !== undefined ? opts.trickle : true;\n  self.destroyed = false;\n  self.connected = false;\n\n  // so Peer object always has same shape (V8 optimization)\n  self.remoteAddress = undefined;\n  self.remoteFamily = undefined;\n  self.remotePort = undefined;\n  self.localAddress = undefined;\n  self.localPort = undefined;\n  self._isWrtc = !!opts.wrtc; // HACK: to fix `wrtc` bug. See issue: #60\n  self._wrtc = opts.wrtc || getBrowserRTC();\n  if (!self._wrtc) {\n    if (typeof window === 'undefined') {\n      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment');\n    } else {\n      throw new Error('No WebRTC support: Not a supported browser');\n    }\n  }\n  self._maxBufferedAmount = opts.highWaterMark;\n  self._pcReady = false;\n  self._channelReady = false;\n  self._iceComplete = false; // ice candidate trickle done (got null candidate)\n  self._channel = null;\n  self._pendingCandidates = [];\n  self._chunk = null;\n  self._cb = null;\n  self._interval = null;\n  self._reconnectTimeout = null;\n  self._pc = new self._wrtc.RTCPeerConnection(self.config, self.constraints);\n  self._pc.oniceconnectionstatechange = self._onIceConnectionStateChange.bind(self);\n  self._pc.onsignalingstatechange = self._onSignalingStateChange.bind(self);\n  self._pc.onicecandidate = self._onIceCandidate.bind(self);\n  if (self.stream) self._pc.addStream(self.stream);\n  self._pc.onaddstream = self._onAddStream.bind(self);\n  if (self.initiator) {\n    self._setupData({\n      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)\n    });\n    self._pc.onnegotiationneeded = once(self._createOffer.bind(self));\n    // Only Chrome triggers \"negotiationneeded\"; this is a workaround for other\n    // implementations\n    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {\n      self._pc.onnegotiationneeded();\n    }\n  } else {\n    self._pc.ondatachannel = self._setupData.bind(self);\n  }\n  self.on('finish', function () {\n    if (self.connected) {\n      // When local peer is finished writing, close connection to remote peer.\n      // Half open connections are currently not supported.\n      // Wait a bit before destroying so the datachannel flushes.\n      // TODO: is there a more reliable way to accomplish this?\n      setTimeout(function () {\n        self._destroy();\n      }, 100);\n    } else {\n      // If data channel is not connected when local peer is finished writing, wait until\n      // data is flushed to network at \"connect\" event.\n      // TODO: is there a more reliable way to accomplish this?\n      self.once('connect', function () {\n        setTimeout(function () {\n          self._destroy();\n        }, 100);\n      });\n    }\n  });\n}\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n\n/**\n * Expose config, constraints, and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [{\n    url: 'stun:23.21.150.121',\n    // deprecated, replaced by `urls`\n    urls: 'stun:23.21.150.121'\n  }]\n};\nPeer.constraints = {};\nPeer.channelConfig = {};\nObject.defineProperty(Peer.prototype, 'bufferSize', {\n  get: function () {\n    var self = this;\n    return self._channel && self._channel.bufferedAmount || 0;\n  }\n});\nPeer.prototype.address = function () {\n  var self = this;\n  return {\n    port: self.localPort,\n    family: 'IPv4',\n    address: self.localAddress\n  };\n};\nPeer.prototype.signal = function (data) {\n  var self = this;\n  if (self.destroyed) throw new Error('cannot signal after peer is destroyed');\n  if (typeof data === 'string') {\n    try {\n      data = JSON.parse(data);\n    } catch (err) {\n      data = {};\n    }\n  }\n  self._debug('signal()');\n  function addIceCandidate(candidate) {\n    try {\n      self._pc.addIceCandidate(new self._wrtc.RTCIceCandidate(candidate), noop, self._onError.bind(self));\n    } catch (err) {\n      self._destroy(new Error('error adding candidate: ' + err.message));\n    }\n  }\n  if (data.sdp) {\n    self._pc.setRemoteDescription(new self._wrtc.RTCSessionDescription(data), function () {\n      if (self.destroyed) return;\n      if (self._pc.remoteDescription.type === 'offer') self._createAnswer();\n      self._pendingCandidates.forEach(addIceCandidate);\n      self._pendingCandidates = [];\n    }, self._onError.bind(self));\n  }\n  if (data.candidate) {\n    if (self._pc.remoteDescription) addIceCandidate(data.candidate);else self._pendingCandidates.push(data.candidate);\n  }\n  if (!data.sdp && !data.candidate) {\n    self._destroy(new Error('signal() called with invalid signal data'));\n  }\n};\n\n/**\n * Send text/binary data to the remote peer.\n * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk\n */\nPeer.prototype.send = function (chunk) {\n  var self = this;\n  if (!isTypedArray.strict(chunk) && !(chunk instanceof ArrayBuffer) && !Buffer.isBuffer(chunk) && typeof chunk !== 'string' && (typeof Blob === 'undefined' || !(chunk instanceof Blob))) {\n    chunk = JSON.stringify(chunk);\n  }\n\n  // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60\n  if (Buffer.isBuffer(chunk) && self._isWrtc) {\n    chunk = new Uint8Array(chunk);\n  }\n  var len = chunk.length || chunk.byteLength || chunk.size;\n  self._channel.send(chunk);\n  self._debug('write: %d bytes', len);\n};\nPeer.prototype.destroy = function (onclose) {\n  var self = this;\n  self._destroy(null, onclose);\n};\nPeer.prototype._destroy = function (err, onclose) {\n  var self = this;\n  if (self.destroyed) return;\n  if (onclose) self.once('close', onclose);\n  self._debug('destroy (error: %s)', err && err.message);\n  self.readable = self.writable = false;\n  if (!self._readableState.ended) self.push(null);\n  if (!self._writableState.finished) self.end();\n  self.destroyed = true;\n  self.connected = false;\n  self._pcReady = false;\n  self._channelReady = false;\n  self._chunk = null;\n  self._cb = null;\n  clearInterval(self._interval);\n  clearTimeout(self._reconnectTimeout);\n  if (self._pc) {\n    try {\n      self._pc.close();\n    } catch (err) {}\n    self._pc.oniceconnectionstatechange = null;\n    self._pc.onsignalingstatechange = null;\n    self._pc.onicecandidate = null;\n  }\n  if (self._channel) {\n    try {\n      self._channel.close();\n    } catch (err) {}\n    self._channel.onmessage = null;\n    self._channel.onopen = null;\n    self._channel.onclose = null;\n  }\n  self._pc = null;\n  self._channel = null;\n  if (err) self.emit('error', err);\n  self.emit('close');\n};\nPeer.prototype._setupData = function (event) {\n  var self = this;\n  self._channel = event.channel;\n  self.channelName = self._channel.label;\n  self._channel.binaryType = 'arraybuffer';\n  self._channel.onmessage = self._onChannelMessage.bind(self);\n  self._channel.onopen = self._onChannelOpen.bind(self);\n  self._channel.onclose = self._onChannelClose.bind(self);\n};\nPeer.prototype._read = function () {};\nPeer.prototype._write = function (chunk, encoding, cb) {\n  var self = this;\n  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'));\n  if (self.connected) {\n    try {\n      self.send(chunk);\n    } catch (err) {\n      return self._onError(err);\n    }\n    if (self._channel.bufferedAmount > self._maxBufferedAmount) {\n      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount);\n      self._cb = cb;\n    } else {\n      cb(null);\n    }\n  } else {\n    self._debug('write before connect');\n    self._chunk = chunk;\n    self._cb = cb;\n  }\n};\nPeer.prototype._createOffer = function () {\n  var self = this;\n  if (self.destroyed) return;\n  self._pc.createOffer(function (offer) {\n    if (self.destroyed) return;\n    offer.sdp = self.sdpTransform(offer.sdp);\n    self._pc.setLocalDescription(offer, noop, self._onError.bind(self));\n    var sendOffer = function () {\n      var signal = self._pc.localDescription || offer;\n      self._debug('signal');\n      self.emit('signal', {\n        type: signal.type,\n        sdp: signal.sdp\n      });\n    };\n    if (self.trickle || self._iceComplete) sendOffer();else self.once('_iceComplete', sendOffer); // wait for candidates\n  }, self._onError.bind(self), self.offerConstraints);\n};\nPeer.prototype._createAnswer = function () {\n  var self = this;\n  if (self.destroyed) return;\n  self._pc.createAnswer(function (answer) {\n    if (self.destroyed) return;\n    answer.sdp = self.sdpTransform(answer.sdp);\n    self._pc.setLocalDescription(answer, noop, self._onError.bind(self));\n    var sendAnswer = function () {\n      var signal = self._pc.localDescription || answer;\n      self._debug('signal');\n      self.emit('signal', {\n        type: signal.type,\n        sdp: signal.sdp\n      });\n    };\n    if (self.trickle || self._iceComplete) sendAnswer();else self.once('_iceComplete', sendAnswer);\n  }, self._onError.bind(self), self.answerConstraints);\n};\nPeer.prototype._onIceConnectionStateChange = function () {\n  var self = this;\n  if (self.destroyed) return;\n  var iceGatheringState = self._pc.iceGatheringState;\n  var iceConnectionState = self._pc.iceConnectionState;\n  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState);\n  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState);\n  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n    clearTimeout(self._reconnectTimeout);\n    self._pcReady = true;\n    self._maybeReady();\n  }\n  if (iceConnectionState === 'disconnected') {\n    if (self.reconnectTimer) {\n      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect\n      clearTimeout(self._reconnectTimeout);\n      self._reconnectTimeout = setTimeout(function () {\n        self._destroy();\n      }, self.reconnectTimer);\n    } else {\n      self._destroy();\n    }\n  }\n  if (iceConnectionState === 'failed') {\n    self._destroy();\n  }\n  if (iceConnectionState === 'closed') {\n    self._destroy();\n  }\n};\nPeer.prototype._maybeReady = function () {\n  var self = this;\n  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady);\n  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return;\n  self._connecting = true;\n  if (!self._pc.getStats) {\n    onStats([]);\n  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) {\n    self._pc.getStats(null, function (res) {\n      var items = [];\n      res.forEach(function (item) {\n        items.push(item);\n      });\n      onStats(items);\n    }, self._onError.bind(self));\n  } else {\n    self._pc.getStats(function (res) {\n      var items = [];\n      res.result().forEach(function (result) {\n        var item = {};\n        result.names().forEach(function (name) {\n          item[name] = result.stat(name);\n        });\n        item.id = result.id;\n        item.type = result.type;\n        item.timestamp = result.timestamp;\n        items.push(item);\n      });\n      onStats(items);\n    });\n  }\n  function onStats(items) {\n    items.forEach(function (item) {\n      if (item.type === 'remotecandidate' && item.candidateType === 'host') {\n        self.remoteAddress = item.ipAddress;\n        self.remotePort = Number(item.portNumber);\n        self.remoteFamily = 'IPv4';\n        self._debug('connect remote: %s:%s (%s)', self.remoteAddress, self.remotePort, self.remoteFamily);\n      } else if (item.type === 'localcandidate' && item.candidateType === 'host') {\n        self.localAddress = item.ipAddress;\n        self.localPort = Number(item.portNumber);\n        self._debug('connect local: %s:%s', self.localAddress, self.localPort);\n      }\n    });\n    self._connecting = false;\n    self.connected = true;\n    if (self._chunk) {\n      try {\n        self.send(self._chunk);\n      } catch (err) {\n        return self._onError(err);\n      }\n      self._chunk = null;\n      self._debug('sent chunk from \"write before connect\"');\n      var cb = self._cb;\n      self._cb = null;\n      cb(null);\n    }\n    self._interval = setInterval(function () {\n      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return;\n      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount);\n      var cb = self._cb;\n      self._cb = null;\n      cb(null);\n    }, 150);\n    if (self._interval.unref) self._interval.unref();\n    self._debug('connect');\n    self.emit('connect');\n  }\n};\nPeer.prototype._onSignalingStateChange = function () {\n  var self = this;\n  if (self.destroyed) return;\n  self._debug('signalingStateChange %s', self._pc.signalingState);\n  self.emit('signalingStateChange', self._pc.signalingState);\n};\nPeer.prototype._onIceCandidate = function (event) {\n  var self = this;\n  if (self.destroyed) return;\n  if (event.candidate && self.trickle) {\n    self.emit('signal', {\n      candidate: {\n        candidate: event.candidate.candidate,\n        sdpMLineIndex: event.candidate.sdpMLineIndex,\n        sdpMid: event.candidate.sdpMid\n      }\n    });\n  } else if (!event.candidate) {\n    self._iceComplete = true;\n    self.emit('_iceComplete');\n  }\n};\nPeer.prototype._onChannelMessage = function (event) {\n  var self = this;\n  if (self.destroyed) return;\n  var data = event.data;\n  self._debug('read: %d bytes', data.byteLength || data.length);\n  if (data instanceof ArrayBuffer) {\n    data = new Buffer(data);\n    self.push(data);\n  } else {\n    try {\n      data = JSON.parse(data);\n    } catch (err) {}\n    self.emit('data', data);\n  }\n};\nPeer.prototype._onChannelOpen = function () {\n  var self = this;\n  if (self.connected || self.destroyed) return;\n  self._debug('on channel open');\n  self._channelReady = true;\n  self._maybeReady();\n};\nPeer.prototype._onChannelClose = function () {\n  var self = this;\n  if (self.destroyed) return;\n  self._debug('on channel close');\n  self._destroy();\n};\nPeer.prototype._onAddStream = function (event) {\n  var self = this;\n  if (self.destroyed) return;\n  self._debug('on add stream');\n  self.emit('stream', event.stream);\n};\nPeer.prototype._onError = function (err) {\n  var self = this;\n  if (self.destroyed) return;\n  self._debug('error %s', err.message || err);\n  self._destroy(err);\n};\nPeer.prototype._debug = function () {\n  var self = this;\n  var args = [].slice.call(arguments);\n  var id = self.channelName && self.channelName.substring(0, 7);\n  args[0] = '[' + id + '] ' + args[0];\n  debug.apply(null, args);\n};\nfunction noop() {}","map":{"version":3,"names":["module","exports","Peer","debug","require","getBrowserRTC","hat","inherits","isTypedArray","once","stream","Duplex","opts","self","_debug","allowHalfOpen","highWaterMark","call","initiator","channelConfig","channelName","config","constraints","offerConstraints","answerConstraints","reconnectTimer","sdpTransform","sdp","trickle","undefined","destroyed","connected","remoteAddress","remoteFamily","remotePort","localAddress","localPort","_isWrtc","wrtc","_wrtc","window","Error","_maxBufferedAmount","_pcReady","_channelReady","_iceComplete","_channel","_pendingCandidates","_chunk","_cb","_interval","_reconnectTimeout","_pc","RTCPeerConnection","oniceconnectionstatechange","_onIceConnectionStateChange","bind","onsignalingstatechange","_onSignalingStateChange","onicecandidate","_onIceCandidate","addStream","onaddstream","_onAddStream","_setupData","channel","createDataChannel","onnegotiationneeded","_createOffer","webkitRTCPeerConnection","ondatachannel","on","setTimeout","_destroy","WEBRTC_SUPPORT","iceServers","url","urls","Object","defineProperty","prototype","get","bufferedAmount","address","port","family","signal","data","JSON","parse","err","addIceCandidate","candidate","RTCIceCandidate","noop","_onError","message","setRemoteDescription","RTCSessionDescription","remoteDescription","type","_createAnswer","forEach","push","send","chunk","strict","ArrayBuffer","Buffer","isBuffer","Blob","stringify","Uint8Array","len","length","byteLength","size","destroy","onclose","readable","writable","_readableState","ended","_writableState","finished","end","clearInterval","clearTimeout","close","onmessage","onopen","emit","event","label","binaryType","_onChannelMessage","_onChannelOpen","_onChannelClose","_read","_write","encoding","cb","createOffer","offer","setLocalDescription","sendOffer","localDescription","createAnswer","answer","sendAnswer","iceGatheringState","iceConnectionState","_maybeReady","_connecting","getStats","onStats","mozRTCPeerConnection","res","items","item","result","names","name","stat","id","timestamp","candidateType","ipAddress","Number","portNumber","setInterval","unref","signalingState","sdpMLineIndex","sdpMid","args","slice","arguments","substring","apply"],"sources":["/home/xilxilx/projects/distsys/alias/frontend/node_modules/simple-peer/index.js"],"sourcesContent":["/* global Blob */\n\nmodule.exports = Peer\n\nvar debug = require('debug')('simple-peer')\nvar getBrowserRTC = require('get-browser-rtc')\nvar hat = require('hat')\nvar inherits = require('inherits')\nvar isTypedArray = require('is-typedarray')\nvar once = require('once')\nvar stream = require('stream')\n\ninherits(Peer, stream.Duplex)\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nfunction Peer (opts) {\n  var self = this\n  if (!(self instanceof Peer)) return new Peer(opts)\n  self._debug('new peer %o', opts)\n\n  if (!opts) opts = {}\n  opts.allowHalfOpen = false\n  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024\n\n  stream.Duplex.call(self, opts)\n\n  self.initiator = opts.initiator || false\n  self.channelConfig = opts.channelConfig || Peer.channelConfig\n  self.channelName = opts.initiator ? (opts.channelName || hat(160)) : null\n  self.config = opts.config || Peer.config\n  self.constraints = opts.constraints || Peer.constraints\n  self.offerConstraints = opts.offerConstraints\n  self.answerConstraints = opts.answerConstraints\n  self.reconnectTimer = opts.reconnectTimer || false\n  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }\n  self.stream = opts.stream || false\n  self.trickle = opts.trickle !== undefined ? opts.trickle : true\n\n  self.destroyed = false\n  self.connected = false\n\n  // so Peer object always has same shape (V8 optimization)\n  self.remoteAddress = undefined\n  self.remoteFamily = undefined\n  self.remotePort = undefined\n  self.localAddress = undefined\n  self.localPort = undefined\n\n  self._isWrtc = !!opts.wrtc // HACK: to fix `wrtc` bug. See issue: #60\n  self._wrtc = opts.wrtc || getBrowserRTC()\n  if (!self._wrtc) {\n    if (typeof window === 'undefined') {\n      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')\n    } else {\n      throw new Error('No WebRTC support: Not a supported browser')\n    }\n  }\n\n  self._maxBufferedAmount = opts.highWaterMark\n  self._pcReady = false\n  self._channelReady = false\n  self._iceComplete = false // ice candidate trickle done (got null candidate)\n  self._channel = null\n  self._pendingCandidates = []\n\n  self._chunk = null\n  self._cb = null\n  self._interval = null\n  self._reconnectTimeout = null\n\n  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)\n  self._pc.oniceconnectionstatechange = self._onIceConnectionStateChange.bind(self)\n  self._pc.onsignalingstatechange = self._onSignalingStateChange.bind(self)\n  self._pc.onicecandidate = self._onIceCandidate.bind(self)\n\n  if (self.stream) self._pc.addStream(self.stream)\n  self._pc.onaddstream = self._onAddStream.bind(self)\n\n  if (self.initiator) {\n    self._setupData({ channel: self._pc.createDataChannel(self.channelName, self.channelConfig) })\n    self._pc.onnegotiationneeded = once(self._createOffer.bind(self))\n    // Only Chrome triggers \"negotiationneeded\"; this is a workaround for other\n    // implementations\n    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {\n      self._pc.onnegotiationneeded()\n    }\n  } else {\n    self._pc.ondatachannel = self._setupData.bind(self)\n  }\n\n  self.on('finish', function () {\n    if (self.connected) {\n      // When local peer is finished writing, close connection to remote peer.\n      // Half open connections are currently not supported.\n      // Wait a bit before destroying so the datachannel flushes.\n      // TODO: is there a more reliable way to accomplish this?\n      setTimeout(function () {\n        self._destroy()\n      }, 100)\n    } else {\n      // If data channel is not connected when local peer is finished writing, wait until\n      // data is flushed to network at \"connect\" event.\n      // TODO: is there a more reliable way to accomplish this?\n      self.once('connect', function () {\n        setTimeout(function () {\n          self._destroy()\n        }, 100)\n      })\n    }\n  })\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose config, constraints, and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [\n    {\n      url: 'stun:23.21.150.121', // deprecated, replaced by `urls`\n      urls: 'stun:23.21.150.121'\n    }\n  ]\n}\nPeer.constraints = {}\nPeer.channelConfig = {}\n\nObject.defineProperty(Peer.prototype, 'bufferSize', {\n  get: function () {\n    var self = this\n    return (self._channel && self._channel.bufferedAmount) || 0\n  }\n})\n\nPeer.prototype.address = function () {\n  var self = this\n  return { port: self.localPort, family: 'IPv4', address: self.localAddress }\n}\n\nPeer.prototype.signal = function (data) {\n  var self = this\n  if (self.destroyed) throw new Error('cannot signal after peer is destroyed')\n  if (typeof data === 'string') {\n    try {\n      data = JSON.parse(data)\n    } catch (err) {\n      data = {}\n    }\n  }\n  self._debug('signal()')\n\n  function addIceCandidate (candidate) {\n    try {\n      self._pc.addIceCandidate(\n        new self._wrtc.RTCIceCandidate(candidate), noop, self._onError.bind(self)\n      )\n    } catch (err) {\n      self._destroy(new Error('error adding candidate: ' + err.message))\n    }\n  }\n\n  if (data.sdp) {\n    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {\n      if (self.destroyed) return\n      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()\n\n      self._pendingCandidates.forEach(addIceCandidate)\n      self._pendingCandidates = []\n    }, self._onError.bind(self))\n  }\n  if (data.candidate) {\n    if (self._pc.remoteDescription) addIceCandidate(data.candidate)\n    else self._pendingCandidates.push(data.candidate)\n  }\n  if (!data.sdp && !data.candidate) {\n    self._destroy(new Error('signal() called with invalid signal data'))\n  }\n}\n\n/**\n * Send text/binary data to the remote peer.\n * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk\n */\nPeer.prototype.send = function (chunk) {\n  var self = this\n\n  if (!isTypedArray.strict(chunk) && !(chunk instanceof ArrayBuffer) &&\n    !Buffer.isBuffer(chunk) && typeof chunk !== 'string' &&\n    (typeof Blob === 'undefined' || !(chunk instanceof Blob))) {\n    chunk = JSON.stringify(chunk)\n  }\n\n  // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60\n  if (Buffer.isBuffer(chunk) && self._isWrtc) {\n    chunk = new Uint8Array(chunk)\n  }\n\n  var len = chunk.length || chunk.byteLength || chunk.size\n  self._channel.send(chunk)\n  self._debug('write: %d bytes', len)\n}\n\nPeer.prototype.destroy = function (onclose) {\n  var self = this\n  self._destroy(null, onclose)\n}\n\nPeer.prototype._destroy = function (err, onclose) {\n  var self = this\n  if (self.destroyed) return\n  if (onclose) self.once('close', onclose)\n\n  self._debug('destroy (error: %s)', err && err.message)\n\n  self.readable = self.writable = false\n\n  if (!self._readableState.ended) self.push(null)\n  if (!self._writableState.finished) self.end()\n\n  self.destroyed = true\n  self.connected = false\n  self._pcReady = false\n  self._channelReady = false\n\n  self._chunk = null\n  self._cb = null\n  clearInterval(self._interval)\n  clearTimeout(self._reconnectTimeout)\n\n  if (self._pc) {\n    try {\n      self._pc.close()\n    } catch (err) {}\n\n    self._pc.oniceconnectionstatechange = null\n    self._pc.onsignalingstatechange = null\n    self._pc.onicecandidate = null\n  }\n\n  if (self._channel) {\n    try {\n      self._channel.close()\n    } catch (err) {}\n\n    self._channel.onmessage = null\n    self._channel.onopen = null\n    self._channel.onclose = null\n  }\n  self._pc = null\n  self._channel = null\n\n  if (err) self.emit('error', err)\n  self.emit('close')\n}\n\nPeer.prototype._setupData = function (event) {\n  var self = this\n  self._channel = event.channel\n  self.channelName = self._channel.label\n\n  self._channel.binaryType = 'arraybuffer'\n  self._channel.onmessage = self._onChannelMessage.bind(self)\n  self._channel.onopen = self._onChannelOpen.bind(self)\n  self._channel.onclose = self._onChannelClose.bind(self)\n}\n\nPeer.prototype._read = function () {}\n\nPeer.prototype._write = function (chunk, encoding, cb) {\n  var self = this\n  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))\n\n  if (self.connected) {\n    try {\n      self.send(chunk)\n    } catch (err) {\n      return self._onError(err)\n    }\n    if (self._channel.bufferedAmount > self._maxBufferedAmount) {\n      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)\n      self._cb = cb\n    } else {\n      cb(null)\n    }\n  } else {\n    self._debug('write before connect')\n    self._chunk = chunk\n    self._cb = cb\n  }\n}\n\nPeer.prototype._createOffer = function () {\n  var self = this\n  if (self.destroyed) return\n\n  self._pc.createOffer(function (offer) {\n    if (self.destroyed) return\n    offer.sdp = self.sdpTransform(offer.sdp)\n    self._pc.setLocalDescription(offer, noop, self._onError.bind(self))\n    var sendOffer = function () {\n      var signal = self._pc.localDescription || offer\n      self._debug('signal')\n      self.emit('signal', {\n        type: signal.type,\n        sdp: signal.sdp\n      })\n    }\n    if (self.trickle || self._iceComplete) sendOffer()\n    else self.once('_iceComplete', sendOffer) // wait for candidates\n  }, self._onError.bind(self), self.offerConstraints)\n}\n\nPeer.prototype._createAnswer = function () {\n  var self = this\n  if (self.destroyed) return\n\n  self._pc.createAnswer(function (answer) {\n    if (self.destroyed) return\n    answer.sdp = self.sdpTransform(answer.sdp)\n    self._pc.setLocalDescription(answer, noop, self._onError.bind(self))\n    var sendAnswer = function () {\n      var signal = self._pc.localDescription || answer\n      self._debug('signal')\n      self.emit('signal', {\n        type: signal.type,\n        sdp: signal.sdp\n      })\n    }\n    if (self.trickle || self._iceComplete) sendAnswer()\n    else self.once('_iceComplete', sendAnswer)\n  }, self._onError.bind(self), self.answerConstraints)\n}\n\nPeer.prototype._onIceConnectionStateChange = function () {\n  var self = this\n  if (self.destroyed) return\n  var iceGatheringState = self._pc.iceGatheringState\n  var iceConnectionState = self._pc.iceConnectionState\n  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)\n  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)\n  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n    clearTimeout(self._reconnectTimeout)\n    self._pcReady = true\n    self._maybeReady()\n  }\n  if (iceConnectionState === 'disconnected') {\n    if (self.reconnectTimer) {\n      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect\n      clearTimeout(self._reconnectTimeout)\n      self._reconnectTimeout = setTimeout(function () {\n        self._destroy()\n      }, self.reconnectTimer)\n    } else {\n      self._destroy()\n    }\n  }\n  if (iceConnectionState === 'failed') {\n    self._destroy()\n  }\n  if (iceConnectionState === 'closed') {\n    self._destroy()\n  }\n}\n\nPeer.prototype._maybeReady = function () {\n  var self = this\n  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)\n  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return\n  self._connecting = true\n\n  if (!self._pc.getStats) {\n    onStats([])\n  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) {\n    self._pc.getStats(null, function (res) {\n      var items = []\n      res.forEach(function (item) {\n        items.push(item)\n      })\n      onStats(items)\n    }, self._onError.bind(self))\n  } else {\n    self._pc.getStats(function (res) {\n      var items = []\n      res.result().forEach(function (result) {\n        var item = {}\n        result.names().forEach(function (name) {\n          item[name] = result.stat(name)\n        })\n        item.id = result.id\n        item.type = result.type\n        item.timestamp = result.timestamp\n        items.push(item)\n      })\n      onStats(items)\n    })\n  }\n\n  function onStats (items) {\n    items.forEach(function (item) {\n      if (item.type === 'remotecandidate' && item.candidateType === 'host') {\n        self.remoteAddress = item.ipAddress\n        self.remotePort = Number(item.portNumber)\n        self.remoteFamily = 'IPv4'\n        self._debug(\n          'connect remote: %s:%s (%s)',\n          self.remoteAddress, self.remotePort, self.remoteFamily\n        )\n      } else if (item.type === 'localcandidate' && item.candidateType === 'host') {\n        self.localAddress = item.ipAddress\n        self.localPort = Number(item.portNumber)\n        self._debug('connect local: %s:%s', self.localAddress, self.localPort)\n      }\n    })\n\n    self._connecting = false\n    self.connected = true\n\n    if (self._chunk) {\n      try {\n        self.send(self._chunk)\n      } catch (err) {\n        return self._onError(err)\n      }\n      self._chunk = null\n      self._debug('sent chunk from \"write before connect\"')\n\n      var cb = self._cb\n      self._cb = null\n      cb(null)\n    }\n\n    self._interval = setInterval(function () {\n      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return\n      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)\n      var cb = self._cb\n      self._cb = null\n      cb(null)\n    }, 150)\n    if (self._interval.unref) self._interval.unref()\n\n    self._debug('connect')\n    self.emit('connect')\n  }\n}\n\nPeer.prototype._onSignalingStateChange = function () {\n  var self = this\n  if (self.destroyed) return\n  self._debug('signalingStateChange %s', self._pc.signalingState)\n  self.emit('signalingStateChange', self._pc.signalingState)\n}\n\nPeer.prototype._onIceCandidate = function (event) {\n  var self = this\n  if (self.destroyed) return\n  if (event.candidate && self.trickle) {\n    self.emit('signal', {\n      candidate: {\n        candidate: event.candidate.candidate,\n        sdpMLineIndex: event.candidate.sdpMLineIndex,\n        sdpMid: event.candidate.sdpMid\n      }\n    })\n  } else if (!event.candidate) {\n    self._iceComplete = true\n    self.emit('_iceComplete')\n  }\n}\n\nPeer.prototype._onChannelMessage = function (event) {\n  var self = this\n  if (self.destroyed) return\n  var data = event.data\n  self._debug('read: %d bytes', data.byteLength || data.length)\n\n  if (data instanceof ArrayBuffer) {\n    data = new Buffer(data)\n    self.push(data)\n  } else {\n    try {\n      data = JSON.parse(data)\n    } catch (err) {}\n    self.emit('data', data)\n  }\n}\n\nPeer.prototype._onChannelOpen = function () {\n  var self = this\n  if (self.connected || self.destroyed) return\n  self._debug('on channel open')\n  self._channelReady = true\n  self._maybeReady()\n}\n\nPeer.prototype._onChannelClose = function () {\n  var self = this\n  if (self.destroyed) return\n  self._debug('on channel close')\n  self._destroy()\n}\n\nPeer.prototype._onAddStream = function (event) {\n  var self = this\n  if (self.destroyed) return\n  self._debug('on add stream')\n  self.emit('stream', event.stream)\n}\n\nPeer.prototype._onError = function (err) {\n  var self = this\n  if (self.destroyed) return\n  self._debug('error %s', err.message || err)\n  self._destroy(err)\n}\n\nPeer.prototype._debug = function () {\n  var self = this\n  var args = [].slice.call(arguments)\n  var id = self.channelName && self.channelName.substring(0, 7)\n  args[0] = '[' + id + '] ' + args[0]\n  debug.apply(null, args)\n}\n\nfunction noop () {}\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAO,GAAGC,IAAI;AAErB,IAAIC,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC,CAAC,aAAa,CAAC;AAC3C,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAC9C,IAAIE,GAAG,GAAGF,OAAO,CAAC,KAAK,CAAC;AACxB,IAAIG,QAAQ,GAAGH,OAAO,CAAC,UAAU,CAAC;AAClC,IAAII,YAAY,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAC3C,IAAIK,IAAI,GAAGL,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIM,MAAM,GAAGN,OAAO,CAAC,QAAQ,CAAC;AAE9BG,QAAQ,CAACL,IAAI,EAAEQ,MAAM,CAACC,MAAM,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA,SAAST,IAAI,CAAEU,IAAI,EAAE;EACnB,IAAIC,IAAI,GAAG,IAAI;EACf,IAAI,EAAEA,IAAI,YAAYX,IAAI,CAAC,EAAE,OAAO,IAAIA,IAAI,CAACU,IAAI,CAAC;EAClDC,IAAI,CAACC,MAAM,CAAC,aAAa,EAAEF,IAAI,CAAC;EAEhC,IAAI,CAACA,IAAI,EAAEA,IAAI,GAAG,CAAC,CAAC;EACpBA,IAAI,CAACG,aAAa,GAAG,KAAK;EAC1B,IAAIH,IAAI,CAACI,aAAa,IAAI,IAAI,EAAEJ,IAAI,CAACI,aAAa,GAAG,IAAI,GAAG,IAAI;EAEhEN,MAAM,CAACC,MAAM,CAACM,IAAI,CAACJ,IAAI,EAAED,IAAI,CAAC;EAE9BC,IAAI,CAACK,SAAS,GAAGN,IAAI,CAACM,SAAS,IAAI,KAAK;EACxCL,IAAI,CAACM,aAAa,GAAGP,IAAI,CAACO,aAAa,IAAIjB,IAAI,CAACiB,aAAa;EAC7DN,IAAI,CAACO,WAAW,GAAGR,IAAI,CAACM,SAAS,GAAIN,IAAI,CAACQ,WAAW,IAAId,GAAG,CAAC,GAAG,CAAC,GAAI,IAAI;EACzEO,IAAI,CAACQ,MAAM,GAAGT,IAAI,CAACS,MAAM,IAAInB,IAAI,CAACmB,MAAM;EACxCR,IAAI,CAACS,WAAW,GAAGV,IAAI,CAACU,WAAW,IAAIpB,IAAI,CAACoB,WAAW;EACvDT,IAAI,CAACU,gBAAgB,GAAGX,IAAI,CAACW,gBAAgB;EAC7CV,IAAI,CAACW,iBAAiB,GAAGZ,IAAI,CAACY,iBAAiB;EAC/CX,IAAI,CAACY,cAAc,GAAGb,IAAI,CAACa,cAAc,IAAI,KAAK;EAClDZ,IAAI,CAACa,YAAY,GAAGd,IAAI,CAACc,YAAY,IAAI,UAAUC,GAAG,EAAE;IAAE,OAAOA,GAAG;EAAC,CAAC;EACtEd,IAAI,CAACH,MAAM,GAAGE,IAAI,CAACF,MAAM,IAAI,KAAK;EAClCG,IAAI,CAACe,OAAO,GAAGhB,IAAI,CAACgB,OAAO,KAAKC,SAAS,GAAGjB,IAAI,CAACgB,OAAO,GAAG,IAAI;EAE/Df,IAAI,CAACiB,SAAS,GAAG,KAAK;EACtBjB,IAAI,CAACkB,SAAS,GAAG,KAAK;;EAEtB;EACAlB,IAAI,CAACmB,aAAa,GAAGH,SAAS;EAC9BhB,IAAI,CAACoB,YAAY,GAAGJ,SAAS;EAC7BhB,IAAI,CAACqB,UAAU,GAAGL,SAAS;EAC3BhB,IAAI,CAACsB,YAAY,GAAGN,SAAS;EAC7BhB,IAAI,CAACuB,SAAS,GAAGP,SAAS;EAE1BhB,IAAI,CAACwB,OAAO,GAAG,CAAC,CAACzB,IAAI,CAAC0B,IAAI,EAAC;EAC3BzB,IAAI,CAAC0B,KAAK,GAAG3B,IAAI,CAAC0B,IAAI,IAAIjC,aAAa,EAAE;EACzC,IAAI,CAACQ,IAAI,CAAC0B,KAAK,EAAE;IACf,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;MACjC,MAAM,IAAIC,KAAK,CAAC,mEAAmE,CAAC;IACtF,CAAC,MAAM;MACL,MAAM,IAAIA,KAAK,CAAC,4CAA4C,CAAC;IAC/D;EACF;EAEA5B,IAAI,CAAC6B,kBAAkB,GAAG9B,IAAI,CAACI,aAAa;EAC5CH,IAAI,CAAC8B,QAAQ,GAAG,KAAK;EACrB9B,IAAI,CAAC+B,aAAa,GAAG,KAAK;EAC1B/B,IAAI,CAACgC,YAAY,GAAG,KAAK,EAAC;EAC1BhC,IAAI,CAACiC,QAAQ,GAAG,IAAI;EACpBjC,IAAI,CAACkC,kBAAkB,GAAG,EAAE;EAE5BlC,IAAI,CAACmC,MAAM,GAAG,IAAI;EAClBnC,IAAI,CAACoC,GAAG,GAAG,IAAI;EACfpC,IAAI,CAACqC,SAAS,GAAG,IAAI;EACrBrC,IAAI,CAACsC,iBAAiB,GAAG,IAAI;EAE7BtC,IAAI,CAACuC,GAAG,GAAG,IAAKvC,IAAI,CAAC0B,KAAK,CAACc,iBAAiB,CAAExC,IAAI,CAACQ,MAAM,EAAER,IAAI,CAACS,WAAW,CAAC;EAC5ET,IAAI,CAACuC,GAAG,CAACE,0BAA0B,GAAGzC,IAAI,CAAC0C,2BAA2B,CAACC,IAAI,CAAC3C,IAAI,CAAC;EACjFA,IAAI,CAACuC,GAAG,CAACK,sBAAsB,GAAG5C,IAAI,CAAC6C,uBAAuB,CAACF,IAAI,CAAC3C,IAAI,CAAC;EACzEA,IAAI,CAACuC,GAAG,CAACO,cAAc,GAAG9C,IAAI,CAAC+C,eAAe,CAACJ,IAAI,CAAC3C,IAAI,CAAC;EAEzD,IAAIA,IAAI,CAACH,MAAM,EAAEG,IAAI,CAACuC,GAAG,CAACS,SAAS,CAAChD,IAAI,CAACH,MAAM,CAAC;EAChDG,IAAI,CAACuC,GAAG,CAACU,WAAW,GAAGjD,IAAI,CAACkD,YAAY,CAACP,IAAI,CAAC3C,IAAI,CAAC;EAEnD,IAAIA,IAAI,CAACK,SAAS,EAAE;IAClBL,IAAI,CAACmD,UAAU,CAAC;MAAEC,OAAO,EAAEpD,IAAI,CAACuC,GAAG,CAACc,iBAAiB,CAACrD,IAAI,CAACO,WAAW,EAAEP,IAAI,CAACM,aAAa;IAAE,CAAC,CAAC;IAC9FN,IAAI,CAACuC,GAAG,CAACe,mBAAmB,GAAG1D,IAAI,CAACI,IAAI,CAACuD,YAAY,CAACZ,IAAI,CAAC3C,IAAI,CAAC,CAAC;IACjE;IACA;IACA,IAAI,OAAO2B,MAAM,KAAK,WAAW,IAAI,CAACA,MAAM,CAAC6B,uBAAuB,EAAE;MACpExD,IAAI,CAACuC,GAAG,CAACe,mBAAmB,EAAE;IAChC;EACF,CAAC,MAAM;IACLtD,IAAI,CAACuC,GAAG,CAACkB,aAAa,GAAGzD,IAAI,CAACmD,UAAU,CAACR,IAAI,CAAC3C,IAAI,CAAC;EACrD;EAEAA,IAAI,CAAC0D,EAAE,CAAC,QAAQ,EAAE,YAAY;IAC5B,IAAI1D,IAAI,CAACkB,SAAS,EAAE;MAClB;MACA;MACA;MACA;MACAyC,UAAU,CAAC,YAAY;QACrB3D,IAAI,CAAC4D,QAAQ,EAAE;MACjB,CAAC,EAAE,GAAG,CAAC;IACT,CAAC,MAAM;MACL;MACA;MACA;MACA5D,IAAI,CAACJ,IAAI,CAAC,SAAS,EAAE,YAAY;QAC/B+D,UAAU,CAAC,YAAY;UACrB3D,IAAI,CAAC4D,QAAQ,EAAE;QACjB,CAAC,EAAE,GAAG,CAAC;MACT,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;AACJ;AAEAvE,IAAI,CAACwE,cAAc,GAAG,CAAC,CAACrE,aAAa,EAAE;;AAEvC;AACA;AACA;AACA;AACA;AACAH,IAAI,CAACmB,MAAM,GAAG;EACZsD,UAAU,EAAE,CACV;IACEC,GAAG,EAAE,oBAAoB;IAAE;IAC3BC,IAAI,EAAE;EACR,CAAC;AAEL,CAAC;AACD3E,IAAI,CAACoB,WAAW,GAAG,CAAC,CAAC;AACrBpB,IAAI,CAACiB,aAAa,GAAG,CAAC,CAAC;AAEvB2D,MAAM,CAACC,cAAc,CAAC7E,IAAI,CAAC8E,SAAS,EAAE,YAAY,EAAE;EAClDC,GAAG,EAAE,YAAY;IACf,IAAIpE,IAAI,GAAG,IAAI;IACf,OAAQA,IAAI,CAACiC,QAAQ,IAAIjC,IAAI,CAACiC,QAAQ,CAACoC,cAAc,IAAK,CAAC;EAC7D;AACF,CAAC,CAAC;AAEFhF,IAAI,CAAC8E,SAAS,CAACG,OAAO,GAAG,YAAY;EACnC,IAAItE,IAAI,GAAG,IAAI;EACf,OAAO;IAAEuE,IAAI,EAAEvE,IAAI,CAACuB,SAAS;IAAEiD,MAAM,EAAE,MAAM;IAAEF,OAAO,EAAEtE,IAAI,CAACsB;EAAa,CAAC;AAC7E,CAAC;AAEDjC,IAAI,CAAC8E,SAAS,CAACM,MAAM,GAAG,UAAUC,IAAI,EAAE;EACtC,IAAI1E,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE,MAAM,IAAIW,KAAK,CAAC,uCAAuC,CAAC;EAC5E,IAAI,OAAO8C,IAAI,KAAK,QAAQ,EAAE;IAC5B,IAAI;MACFA,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;IACzB,CAAC,CAAC,OAAOG,GAAG,EAAE;MACZH,IAAI,GAAG,CAAC,CAAC;IACX;EACF;EACA1E,IAAI,CAACC,MAAM,CAAC,UAAU,CAAC;EAEvB,SAAS6E,eAAe,CAAEC,SAAS,EAAE;IACnC,IAAI;MACF/E,IAAI,CAACuC,GAAG,CAACuC,eAAe,CACtB,IAAI9E,IAAI,CAAC0B,KAAK,CAACsD,eAAe,CAACD,SAAS,CAAC,EAAEE,IAAI,EAAEjF,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,CAC1E;IACH,CAAC,CAAC,OAAO6E,GAAG,EAAE;MACZ7E,IAAI,CAAC4D,QAAQ,CAAC,IAAIhC,KAAK,CAAC,0BAA0B,GAAGiD,GAAG,CAACM,OAAO,CAAC,CAAC;IACpE;EACF;EAEA,IAAIT,IAAI,CAAC5D,GAAG,EAAE;IACZd,IAAI,CAACuC,GAAG,CAAC6C,oBAAoB,CAAC,IAAKpF,IAAI,CAAC0B,KAAK,CAAC2D,qBAAqB,CAAEX,IAAI,CAAC,EAAE,YAAY;MACtF,IAAI1E,IAAI,CAACiB,SAAS,EAAE;MACpB,IAAIjB,IAAI,CAACuC,GAAG,CAAC+C,iBAAiB,CAACC,IAAI,KAAK,OAAO,EAAEvF,IAAI,CAACwF,aAAa,EAAE;MAErExF,IAAI,CAACkC,kBAAkB,CAACuD,OAAO,CAACX,eAAe,CAAC;MAChD9E,IAAI,CAACkC,kBAAkB,GAAG,EAAE;IAC9B,CAAC,EAAElC,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,CAAC;EAC9B;EACA,IAAI0E,IAAI,CAACK,SAAS,EAAE;IAClB,IAAI/E,IAAI,CAACuC,GAAG,CAAC+C,iBAAiB,EAAER,eAAe,CAACJ,IAAI,CAACK,SAAS,CAAC,MAC1D/E,IAAI,CAACkC,kBAAkB,CAACwD,IAAI,CAAChB,IAAI,CAACK,SAAS,CAAC;EACnD;EACA,IAAI,CAACL,IAAI,CAAC5D,GAAG,IAAI,CAAC4D,IAAI,CAACK,SAAS,EAAE;IAChC/E,IAAI,CAAC4D,QAAQ,CAAC,IAAIhC,KAAK,CAAC,0CAA0C,CAAC,CAAC;EACtE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAvC,IAAI,CAAC8E,SAAS,CAACwB,IAAI,GAAG,UAAUC,KAAK,EAAE;EACrC,IAAI5F,IAAI,GAAG,IAAI;EAEf,IAAI,CAACL,YAAY,CAACkG,MAAM,CAACD,KAAK,CAAC,IAAI,EAAEA,KAAK,YAAYE,WAAW,CAAC,IAChE,CAACC,MAAM,CAACC,QAAQ,CAACJ,KAAK,CAAC,IAAI,OAAOA,KAAK,KAAK,QAAQ,KACnD,OAAOK,IAAI,KAAK,WAAW,IAAI,EAAEL,KAAK,YAAYK,IAAI,CAAC,CAAC,EAAE;IAC3DL,KAAK,GAAGjB,IAAI,CAACuB,SAAS,CAACN,KAAK,CAAC;EAC/B;;EAEA;EACA,IAAIG,MAAM,CAACC,QAAQ,CAACJ,KAAK,CAAC,IAAI5F,IAAI,CAACwB,OAAO,EAAE;IAC1CoE,KAAK,GAAG,IAAIO,UAAU,CAACP,KAAK,CAAC;EAC/B;EAEA,IAAIQ,GAAG,GAAGR,KAAK,CAACS,MAAM,IAAIT,KAAK,CAACU,UAAU,IAAIV,KAAK,CAACW,IAAI;EACxDvG,IAAI,CAACiC,QAAQ,CAAC0D,IAAI,CAACC,KAAK,CAAC;EACzB5F,IAAI,CAACC,MAAM,CAAC,iBAAiB,EAAEmG,GAAG,CAAC;AACrC,CAAC;AAED/G,IAAI,CAAC8E,SAAS,CAACqC,OAAO,GAAG,UAAUC,OAAO,EAAE;EAC1C,IAAIzG,IAAI,GAAG,IAAI;EACfA,IAAI,CAAC4D,QAAQ,CAAC,IAAI,EAAE6C,OAAO,CAAC;AAC9B,CAAC;AAEDpH,IAAI,CAAC8E,SAAS,CAACP,QAAQ,GAAG,UAAUiB,GAAG,EAAE4B,OAAO,EAAE;EAChD,IAAIzG,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpB,IAAIwF,OAAO,EAAEzG,IAAI,CAACJ,IAAI,CAAC,OAAO,EAAE6G,OAAO,CAAC;EAExCzG,IAAI,CAACC,MAAM,CAAC,qBAAqB,EAAE4E,GAAG,IAAIA,GAAG,CAACM,OAAO,CAAC;EAEtDnF,IAAI,CAAC0G,QAAQ,GAAG1G,IAAI,CAAC2G,QAAQ,GAAG,KAAK;EAErC,IAAI,CAAC3G,IAAI,CAAC4G,cAAc,CAACC,KAAK,EAAE7G,IAAI,CAAC0F,IAAI,CAAC,IAAI,CAAC;EAC/C,IAAI,CAAC1F,IAAI,CAAC8G,cAAc,CAACC,QAAQ,EAAE/G,IAAI,CAACgH,GAAG,EAAE;EAE7ChH,IAAI,CAACiB,SAAS,GAAG,IAAI;EACrBjB,IAAI,CAACkB,SAAS,GAAG,KAAK;EACtBlB,IAAI,CAAC8B,QAAQ,GAAG,KAAK;EACrB9B,IAAI,CAAC+B,aAAa,GAAG,KAAK;EAE1B/B,IAAI,CAACmC,MAAM,GAAG,IAAI;EAClBnC,IAAI,CAACoC,GAAG,GAAG,IAAI;EACf6E,aAAa,CAACjH,IAAI,CAACqC,SAAS,CAAC;EAC7B6E,YAAY,CAAClH,IAAI,CAACsC,iBAAiB,CAAC;EAEpC,IAAItC,IAAI,CAACuC,GAAG,EAAE;IACZ,IAAI;MACFvC,IAAI,CAACuC,GAAG,CAAC4E,KAAK,EAAE;IAClB,CAAC,CAAC,OAAOtC,GAAG,EAAE,CAAC;IAEf7E,IAAI,CAACuC,GAAG,CAACE,0BAA0B,GAAG,IAAI;IAC1CzC,IAAI,CAACuC,GAAG,CAACK,sBAAsB,GAAG,IAAI;IACtC5C,IAAI,CAACuC,GAAG,CAACO,cAAc,GAAG,IAAI;EAChC;EAEA,IAAI9C,IAAI,CAACiC,QAAQ,EAAE;IACjB,IAAI;MACFjC,IAAI,CAACiC,QAAQ,CAACkF,KAAK,EAAE;IACvB,CAAC,CAAC,OAAOtC,GAAG,EAAE,CAAC;IAEf7E,IAAI,CAACiC,QAAQ,CAACmF,SAAS,GAAG,IAAI;IAC9BpH,IAAI,CAACiC,QAAQ,CAACoF,MAAM,GAAG,IAAI;IAC3BrH,IAAI,CAACiC,QAAQ,CAACwE,OAAO,GAAG,IAAI;EAC9B;EACAzG,IAAI,CAACuC,GAAG,GAAG,IAAI;EACfvC,IAAI,CAACiC,QAAQ,GAAG,IAAI;EAEpB,IAAI4C,GAAG,EAAE7E,IAAI,CAACsH,IAAI,CAAC,OAAO,EAAEzC,GAAG,CAAC;EAChC7E,IAAI,CAACsH,IAAI,CAAC,OAAO,CAAC;AACpB,CAAC;AAEDjI,IAAI,CAAC8E,SAAS,CAAChB,UAAU,GAAG,UAAUoE,KAAK,EAAE;EAC3C,IAAIvH,IAAI,GAAG,IAAI;EACfA,IAAI,CAACiC,QAAQ,GAAGsF,KAAK,CAACnE,OAAO;EAC7BpD,IAAI,CAACO,WAAW,GAAGP,IAAI,CAACiC,QAAQ,CAACuF,KAAK;EAEtCxH,IAAI,CAACiC,QAAQ,CAACwF,UAAU,GAAG,aAAa;EACxCzH,IAAI,CAACiC,QAAQ,CAACmF,SAAS,GAAGpH,IAAI,CAAC0H,iBAAiB,CAAC/E,IAAI,CAAC3C,IAAI,CAAC;EAC3DA,IAAI,CAACiC,QAAQ,CAACoF,MAAM,GAAGrH,IAAI,CAAC2H,cAAc,CAAChF,IAAI,CAAC3C,IAAI,CAAC;EACrDA,IAAI,CAACiC,QAAQ,CAACwE,OAAO,GAAGzG,IAAI,CAAC4H,eAAe,CAACjF,IAAI,CAAC3C,IAAI,CAAC;AACzD,CAAC;AAEDX,IAAI,CAAC8E,SAAS,CAAC0D,KAAK,GAAG,YAAY,CAAC,CAAC;AAErCxI,IAAI,CAAC8E,SAAS,CAAC2D,MAAM,GAAG,UAAUlC,KAAK,EAAEmC,QAAQ,EAAEC,EAAE,EAAE;EACrD,IAAIhI,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE,OAAO+G,EAAE,CAAC,IAAIpG,KAAK,CAAC,sCAAsC,CAAC,CAAC;EAEhF,IAAI5B,IAAI,CAACkB,SAAS,EAAE;IAClB,IAAI;MACFlB,IAAI,CAAC2F,IAAI,CAACC,KAAK,CAAC;IAClB,CAAC,CAAC,OAAOf,GAAG,EAAE;MACZ,OAAO7E,IAAI,CAACkF,QAAQ,CAACL,GAAG,CAAC;IAC3B;IACA,IAAI7E,IAAI,CAACiC,QAAQ,CAACoC,cAAc,GAAGrE,IAAI,CAAC6B,kBAAkB,EAAE;MAC1D7B,IAAI,CAACC,MAAM,CAAC,uCAAuC,EAAED,IAAI,CAACiC,QAAQ,CAACoC,cAAc,CAAC;MAClFrE,IAAI,CAACoC,GAAG,GAAG4F,EAAE;IACf,CAAC,MAAM;MACLA,EAAE,CAAC,IAAI,CAAC;IACV;EACF,CAAC,MAAM;IACLhI,IAAI,CAACC,MAAM,CAAC,sBAAsB,CAAC;IACnCD,IAAI,CAACmC,MAAM,GAAGyD,KAAK;IACnB5F,IAAI,CAACoC,GAAG,GAAG4F,EAAE;EACf;AACF,CAAC;AAED3I,IAAI,CAAC8E,SAAS,CAACZ,YAAY,GAAG,YAAY;EACxC,IAAIvD,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EAEpBjB,IAAI,CAACuC,GAAG,CAAC0F,WAAW,CAAC,UAAUC,KAAK,EAAE;IACpC,IAAIlI,IAAI,CAACiB,SAAS,EAAE;IACpBiH,KAAK,CAACpH,GAAG,GAAGd,IAAI,CAACa,YAAY,CAACqH,KAAK,CAACpH,GAAG,CAAC;IACxCd,IAAI,CAACuC,GAAG,CAAC4F,mBAAmB,CAACD,KAAK,EAAEjD,IAAI,EAAEjF,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,CAAC;IACnE,IAAIoI,SAAS,GAAG,YAAY;MAC1B,IAAI3D,MAAM,GAAGzE,IAAI,CAACuC,GAAG,CAAC8F,gBAAgB,IAAIH,KAAK;MAC/ClI,IAAI,CAACC,MAAM,CAAC,QAAQ,CAAC;MACrBD,IAAI,CAACsH,IAAI,CAAC,QAAQ,EAAE;QAClB/B,IAAI,EAAEd,MAAM,CAACc,IAAI;QACjBzE,GAAG,EAAE2D,MAAM,CAAC3D;MACd,CAAC,CAAC;IACJ,CAAC;IACD,IAAId,IAAI,CAACe,OAAO,IAAIf,IAAI,CAACgC,YAAY,EAAEoG,SAAS,EAAE,MAC7CpI,IAAI,CAACJ,IAAI,CAAC,cAAc,EAAEwI,SAAS,CAAC,EAAC;EAC5C,CAAC,EAAEpI,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,EAAEA,IAAI,CAACU,gBAAgB,CAAC;AACrD,CAAC;AAEDrB,IAAI,CAAC8E,SAAS,CAACqB,aAAa,GAAG,YAAY;EACzC,IAAIxF,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EAEpBjB,IAAI,CAACuC,GAAG,CAAC+F,YAAY,CAAC,UAAUC,MAAM,EAAE;IACtC,IAAIvI,IAAI,CAACiB,SAAS,EAAE;IACpBsH,MAAM,CAACzH,GAAG,GAAGd,IAAI,CAACa,YAAY,CAAC0H,MAAM,CAACzH,GAAG,CAAC;IAC1Cd,IAAI,CAACuC,GAAG,CAAC4F,mBAAmB,CAACI,MAAM,EAAEtD,IAAI,EAAEjF,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,CAAC;IACpE,IAAIwI,UAAU,GAAG,YAAY;MAC3B,IAAI/D,MAAM,GAAGzE,IAAI,CAACuC,GAAG,CAAC8F,gBAAgB,IAAIE,MAAM;MAChDvI,IAAI,CAACC,MAAM,CAAC,QAAQ,CAAC;MACrBD,IAAI,CAACsH,IAAI,CAAC,QAAQ,EAAE;QAClB/B,IAAI,EAAEd,MAAM,CAACc,IAAI;QACjBzE,GAAG,EAAE2D,MAAM,CAAC3D;MACd,CAAC,CAAC;IACJ,CAAC;IACD,IAAId,IAAI,CAACe,OAAO,IAAIf,IAAI,CAACgC,YAAY,EAAEwG,UAAU,EAAE,MAC9CxI,IAAI,CAACJ,IAAI,CAAC,cAAc,EAAE4I,UAAU,CAAC;EAC5C,CAAC,EAAExI,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,EAAEA,IAAI,CAACW,iBAAiB,CAAC;AACtD,CAAC;AAEDtB,IAAI,CAAC8E,SAAS,CAACzB,2BAA2B,GAAG,YAAY;EACvD,IAAI1C,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpB,IAAIwH,iBAAiB,GAAGzI,IAAI,CAACuC,GAAG,CAACkG,iBAAiB;EAClD,IAAIC,kBAAkB,GAAG1I,IAAI,CAACuC,GAAG,CAACmG,kBAAkB;EACpD1I,IAAI,CAACC,MAAM,CAAC,gCAAgC,EAAEwI,iBAAiB,EAAEC,kBAAkB,CAAC;EACpF1I,IAAI,CAACsH,IAAI,CAAC,0BAA0B,EAAEmB,iBAAiB,EAAEC,kBAAkB,CAAC;EAC5E,IAAIA,kBAAkB,KAAK,WAAW,IAAIA,kBAAkB,KAAK,WAAW,EAAE;IAC5ExB,YAAY,CAAClH,IAAI,CAACsC,iBAAiB,CAAC;IACpCtC,IAAI,CAAC8B,QAAQ,GAAG,IAAI;IACpB9B,IAAI,CAAC2I,WAAW,EAAE;EACpB;EACA,IAAID,kBAAkB,KAAK,cAAc,EAAE;IACzC,IAAI1I,IAAI,CAACY,cAAc,EAAE;MACvB;MACAsG,YAAY,CAAClH,IAAI,CAACsC,iBAAiB,CAAC;MACpCtC,IAAI,CAACsC,iBAAiB,GAAGqB,UAAU,CAAC,YAAY;QAC9C3D,IAAI,CAAC4D,QAAQ,EAAE;MACjB,CAAC,EAAE5D,IAAI,CAACY,cAAc,CAAC;IACzB,CAAC,MAAM;MACLZ,IAAI,CAAC4D,QAAQ,EAAE;IACjB;EACF;EACA,IAAI8E,kBAAkB,KAAK,QAAQ,EAAE;IACnC1I,IAAI,CAAC4D,QAAQ,EAAE;EACjB;EACA,IAAI8E,kBAAkB,KAAK,QAAQ,EAAE;IACnC1I,IAAI,CAAC4D,QAAQ,EAAE;EACjB;AACF,CAAC;AAEDvE,IAAI,CAAC8E,SAAS,CAACwE,WAAW,GAAG,YAAY;EACvC,IAAI3I,IAAI,GAAG,IAAI;EACfA,IAAI,CAACC,MAAM,CAAC,6BAA6B,EAAED,IAAI,CAAC8B,QAAQ,EAAE9B,IAAI,CAAC+B,aAAa,CAAC;EAC7E,IAAI/B,IAAI,CAACkB,SAAS,IAAIlB,IAAI,CAAC4I,WAAW,IAAI,CAAC5I,IAAI,CAAC8B,QAAQ,IAAI,CAAC9B,IAAI,CAAC+B,aAAa,EAAE;EACjF/B,IAAI,CAAC4I,WAAW,GAAG,IAAI;EAEvB,IAAI,CAAC5I,IAAI,CAACuC,GAAG,CAACsG,QAAQ,EAAE;IACtBC,OAAO,CAAC,EAAE,CAAC;EACb,CAAC,MAAM,IAAI,OAAOnH,MAAM,KAAK,WAAW,IAAI,CAAC,CAACA,MAAM,CAACoH,oBAAoB,EAAE;IACzE/I,IAAI,CAACuC,GAAG,CAACsG,QAAQ,CAAC,IAAI,EAAE,UAAUG,GAAG,EAAE;MACrC,IAAIC,KAAK,GAAG,EAAE;MACdD,GAAG,CAACvD,OAAO,CAAC,UAAUyD,IAAI,EAAE;QAC1BD,KAAK,CAACvD,IAAI,CAACwD,IAAI,CAAC;MAClB,CAAC,CAAC;MACFJ,OAAO,CAACG,KAAK,CAAC;IAChB,CAAC,EAAEjJ,IAAI,CAACkF,QAAQ,CAACvC,IAAI,CAAC3C,IAAI,CAAC,CAAC;EAC9B,CAAC,MAAM;IACLA,IAAI,CAACuC,GAAG,CAACsG,QAAQ,CAAC,UAAUG,GAAG,EAAE;MAC/B,IAAIC,KAAK,GAAG,EAAE;MACdD,GAAG,CAACG,MAAM,EAAE,CAAC1D,OAAO,CAAC,UAAU0D,MAAM,EAAE;QACrC,IAAID,IAAI,GAAG,CAAC,CAAC;QACbC,MAAM,CAACC,KAAK,EAAE,CAAC3D,OAAO,CAAC,UAAU4D,IAAI,EAAE;UACrCH,IAAI,CAACG,IAAI,CAAC,GAAGF,MAAM,CAACG,IAAI,CAACD,IAAI,CAAC;QAChC,CAAC,CAAC;QACFH,IAAI,CAACK,EAAE,GAAGJ,MAAM,CAACI,EAAE;QACnBL,IAAI,CAAC3D,IAAI,GAAG4D,MAAM,CAAC5D,IAAI;QACvB2D,IAAI,CAACM,SAAS,GAAGL,MAAM,CAACK,SAAS;QACjCP,KAAK,CAACvD,IAAI,CAACwD,IAAI,CAAC;MAClB,CAAC,CAAC;MACFJ,OAAO,CAACG,KAAK,CAAC;IAChB,CAAC,CAAC;EACJ;EAEA,SAASH,OAAO,CAAEG,KAAK,EAAE;IACvBA,KAAK,CAACxD,OAAO,CAAC,UAAUyD,IAAI,EAAE;MAC5B,IAAIA,IAAI,CAAC3D,IAAI,KAAK,iBAAiB,IAAI2D,IAAI,CAACO,aAAa,KAAK,MAAM,EAAE;QACpEzJ,IAAI,CAACmB,aAAa,GAAG+H,IAAI,CAACQ,SAAS;QACnC1J,IAAI,CAACqB,UAAU,GAAGsI,MAAM,CAACT,IAAI,CAACU,UAAU,CAAC;QACzC5J,IAAI,CAACoB,YAAY,GAAG,MAAM;QAC1BpB,IAAI,CAACC,MAAM,CACT,4BAA4B,EAC5BD,IAAI,CAACmB,aAAa,EAAEnB,IAAI,CAACqB,UAAU,EAAErB,IAAI,CAACoB,YAAY,CACvD;MACH,CAAC,MAAM,IAAI8H,IAAI,CAAC3D,IAAI,KAAK,gBAAgB,IAAI2D,IAAI,CAACO,aAAa,KAAK,MAAM,EAAE;QAC1EzJ,IAAI,CAACsB,YAAY,GAAG4H,IAAI,CAACQ,SAAS;QAClC1J,IAAI,CAACuB,SAAS,GAAGoI,MAAM,CAACT,IAAI,CAACU,UAAU,CAAC;QACxC5J,IAAI,CAACC,MAAM,CAAC,sBAAsB,EAAED,IAAI,CAACsB,YAAY,EAAEtB,IAAI,CAACuB,SAAS,CAAC;MACxE;IACF,CAAC,CAAC;IAEFvB,IAAI,CAAC4I,WAAW,GAAG,KAAK;IACxB5I,IAAI,CAACkB,SAAS,GAAG,IAAI;IAErB,IAAIlB,IAAI,CAACmC,MAAM,EAAE;MACf,IAAI;QACFnC,IAAI,CAAC2F,IAAI,CAAC3F,IAAI,CAACmC,MAAM,CAAC;MACxB,CAAC,CAAC,OAAO0C,GAAG,EAAE;QACZ,OAAO7E,IAAI,CAACkF,QAAQ,CAACL,GAAG,CAAC;MAC3B;MACA7E,IAAI,CAACmC,MAAM,GAAG,IAAI;MAClBnC,IAAI,CAACC,MAAM,CAAC,wCAAwC,CAAC;MAErD,IAAI+H,EAAE,GAAGhI,IAAI,CAACoC,GAAG;MACjBpC,IAAI,CAACoC,GAAG,GAAG,IAAI;MACf4F,EAAE,CAAC,IAAI,CAAC;IACV;IAEAhI,IAAI,CAACqC,SAAS,GAAGwH,WAAW,CAAC,YAAY;MACvC,IAAI,CAAC7J,IAAI,CAACoC,GAAG,IAAI,CAACpC,IAAI,CAACiC,QAAQ,IAAIjC,IAAI,CAACiC,QAAQ,CAACoC,cAAc,GAAGrE,IAAI,CAAC6B,kBAAkB,EAAE;MAC3F7B,IAAI,CAACC,MAAM,CAAC,wCAAwC,EAAED,IAAI,CAACiC,QAAQ,CAACoC,cAAc,CAAC;MACnF,IAAI2D,EAAE,GAAGhI,IAAI,CAACoC,GAAG;MACjBpC,IAAI,CAACoC,GAAG,GAAG,IAAI;MACf4F,EAAE,CAAC,IAAI,CAAC;IACV,CAAC,EAAE,GAAG,CAAC;IACP,IAAIhI,IAAI,CAACqC,SAAS,CAACyH,KAAK,EAAE9J,IAAI,CAACqC,SAAS,CAACyH,KAAK,EAAE;IAEhD9J,IAAI,CAACC,MAAM,CAAC,SAAS,CAAC;IACtBD,IAAI,CAACsH,IAAI,CAAC,SAAS,CAAC;EACtB;AACF,CAAC;AAEDjI,IAAI,CAAC8E,SAAS,CAACtB,uBAAuB,GAAG,YAAY;EACnD,IAAI7C,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpBjB,IAAI,CAACC,MAAM,CAAC,yBAAyB,EAAED,IAAI,CAACuC,GAAG,CAACwH,cAAc,CAAC;EAC/D/J,IAAI,CAACsH,IAAI,CAAC,sBAAsB,EAAEtH,IAAI,CAACuC,GAAG,CAACwH,cAAc,CAAC;AAC5D,CAAC;AAED1K,IAAI,CAAC8E,SAAS,CAACpB,eAAe,GAAG,UAAUwE,KAAK,EAAE;EAChD,IAAIvH,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpB,IAAIsG,KAAK,CAACxC,SAAS,IAAI/E,IAAI,CAACe,OAAO,EAAE;IACnCf,IAAI,CAACsH,IAAI,CAAC,QAAQ,EAAE;MAClBvC,SAAS,EAAE;QACTA,SAAS,EAAEwC,KAAK,CAACxC,SAAS,CAACA,SAAS;QACpCiF,aAAa,EAAEzC,KAAK,CAACxC,SAAS,CAACiF,aAAa;QAC5CC,MAAM,EAAE1C,KAAK,CAACxC,SAAS,CAACkF;MAC1B;IACF,CAAC,CAAC;EACJ,CAAC,MAAM,IAAI,CAAC1C,KAAK,CAACxC,SAAS,EAAE;IAC3B/E,IAAI,CAACgC,YAAY,GAAG,IAAI;IACxBhC,IAAI,CAACsH,IAAI,CAAC,cAAc,CAAC;EAC3B;AACF,CAAC;AAEDjI,IAAI,CAAC8E,SAAS,CAACuD,iBAAiB,GAAG,UAAUH,KAAK,EAAE;EAClD,IAAIvH,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpB,IAAIyD,IAAI,GAAG6C,KAAK,CAAC7C,IAAI;EACrB1E,IAAI,CAACC,MAAM,CAAC,gBAAgB,EAAEyE,IAAI,CAAC4B,UAAU,IAAI5B,IAAI,CAAC2B,MAAM,CAAC;EAE7D,IAAI3B,IAAI,YAAYoB,WAAW,EAAE;IAC/BpB,IAAI,GAAG,IAAIqB,MAAM,CAACrB,IAAI,CAAC;IACvB1E,IAAI,CAAC0F,IAAI,CAAChB,IAAI,CAAC;EACjB,CAAC,MAAM;IACL,IAAI;MACFA,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;IACzB,CAAC,CAAC,OAAOG,GAAG,EAAE,CAAC;IACf7E,IAAI,CAACsH,IAAI,CAAC,MAAM,EAAE5C,IAAI,CAAC;EACzB;AACF,CAAC;AAEDrF,IAAI,CAAC8E,SAAS,CAACwD,cAAc,GAAG,YAAY;EAC1C,IAAI3H,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACkB,SAAS,IAAIlB,IAAI,CAACiB,SAAS,EAAE;EACtCjB,IAAI,CAACC,MAAM,CAAC,iBAAiB,CAAC;EAC9BD,IAAI,CAAC+B,aAAa,GAAG,IAAI;EACzB/B,IAAI,CAAC2I,WAAW,EAAE;AACpB,CAAC;AAEDtJ,IAAI,CAAC8E,SAAS,CAACyD,eAAe,GAAG,YAAY;EAC3C,IAAI5H,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpBjB,IAAI,CAACC,MAAM,CAAC,kBAAkB,CAAC;EAC/BD,IAAI,CAAC4D,QAAQ,EAAE;AACjB,CAAC;AAEDvE,IAAI,CAAC8E,SAAS,CAACjB,YAAY,GAAG,UAAUqE,KAAK,EAAE;EAC7C,IAAIvH,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpBjB,IAAI,CAACC,MAAM,CAAC,eAAe,CAAC;EAC5BD,IAAI,CAACsH,IAAI,CAAC,QAAQ,EAAEC,KAAK,CAAC1H,MAAM,CAAC;AACnC,CAAC;AAEDR,IAAI,CAAC8E,SAAS,CAACe,QAAQ,GAAG,UAAUL,GAAG,EAAE;EACvC,IAAI7E,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACiB,SAAS,EAAE;EACpBjB,IAAI,CAACC,MAAM,CAAC,UAAU,EAAE4E,GAAG,CAACM,OAAO,IAAIN,GAAG,CAAC;EAC3C7E,IAAI,CAAC4D,QAAQ,CAACiB,GAAG,CAAC;AACpB,CAAC;AAEDxF,IAAI,CAAC8E,SAAS,CAAClE,MAAM,GAAG,YAAY;EAClC,IAAID,IAAI,GAAG,IAAI;EACf,IAAIkK,IAAI,GAAG,EAAE,CAACC,KAAK,CAAC/J,IAAI,CAACgK,SAAS,CAAC;EACnC,IAAIb,EAAE,GAAGvJ,IAAI,CAACO,WAAW,IAAIP,IAAI,CAACO,WAAW,CAAC8J,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;EAC7DH,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGX,EAAE,GAAG,IAAI,GAAGW,IAAI,CAAC,CAAC,CAAC;EACnC5K,KAAK,CAACgL,KAAK,CAAC,IAAI,EAAEJ,IAAI,CAAC;AACzB,CAAC;AAED,SAASjF,IAAI,GAAI,CAAC"},"metadata":{},"sourceType":"script"}